# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2013, Russell Keith-Magee
# This file is distributed under the same license as the BeeWare package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: BeeWare 0.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-26 20:12+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"

#: ../../tutorial/tutorial-7.rst:3
msgid "Tutorial 7 - Making it Smooooth"
msgstr ""

#: ../../tutorial/tutorial-7.rst:5
msgid ""
"Unless you've got a *really* fast internet connection, you may notice "
"that when you press the button, the GUI for your app locks up for a "
"little bit. This is because the web request we have made is "
"*synchronous*. When our application makes the web request, it waits for "
"the API to return a response before continuing. While it's waiting, it "
"*isn't* allowing the application to redraw - and as a result, the "
"application locks up."
msgstr ""

#: ../../tutorial/tutorial-7.rst:13
msgid "GUI Event Loops"
msgstr ""

#: ../../tutorial/tutorial-7.rst:15
msgid ""
"To understand why this happens, we need to dig into the details of how a "
"GUI application works. The specifics vary depending on the platform; but "
"the high level concepts are the same, no matter the platform or GUI "
"environment you're using."
msgstr ""

#: ../../tutorial/tutorial-7.rst:20
msgid "A GUI app is, fundamentally, a single loop that looks something like::"
msgstr ""

#: ../../tutorial/tutorial-7.rst:26
msgid ""
"This loop is called the *Event Loop*. (These aren't actual method names -"
" it's an illustration of what is going on in \"pseudo-code\")."
msgstr ""

#: ../../tutorial/tutorial-7.rst:29
msgid ""
"When you click on a button, or drag a scroll bar, or type a key, you are "
"generating an \"event\". That \"event\" is put onto a queue, and the app "
"will process the queue of events when it next has the opportunity to do "
"so. The user code that is triggered in response to the event is called an"
" *event handler*. These event handlers are invoked as part of the "
"``process_events()`` call."
msgstr ""

#: ../../tutorial/tutorial-7.rst:35
msgid ""
"Once an app has processed all the available events, it will ``redraw()`` "
"the GUI. This takes into account any changes that the events have caused "
"to the display of the app, as well as anything else that is going on in "
"the operating system - for example, the windows of another app may "
"obscure or reveal part of our app's window, and our app's redraw will "
"need to reflect the portion of the window that is currently visible."
msgstr ""

#: ../../tutorial/tutorial-7.rst:42
msgid ""
"The important detail to notice: while an application is processing an "
"event, *it can't redraw*, and *it can't process other events*."
msgstr ""

#: ../../tutorial/tutorial-7.rst:45
msgid ""
"This means any user logic contained in an event handler needs to complete"
" quickly. Any delay in completing the event handler will be observed by "
"the user as a slowdown (or stop) in GUI updates. If this delay is long "
"enough, your operating system may report this as a problem - the macOS "
"\"Beachball\" and Windows \"Hourglass\" are the operating system telling "
"you that your app is taking too long in an event handler."
msgstr ""

#: ../../tutorial/tutorial-7.rst:52
msgid ""
"Simple operations like \"update a label\", or \"recompute the total of "
"the inputs\" are easy to complete quickly. However, there are a lot of "
"operations that can't be completed quickly. If you're performing a "
"complex mathematical calculation, or indexing all the files on a file "
"system, or performing a large network request, you can't \"just do it "
"quickly\" - the operations are inherently slow."
msgstr ""

#: ../../tutorial/tutorial-7.rst:58
msgid "So - how do we perform long-lived operations in a GUI application?"
msgstr ""

#: ../../tutorial/tutorial-7.rst:61
msgid "Asynchronous programming"
msgstr ""

#: ../../tutorial/tutorial-7.rst:63
msgid ""
"What we need is a way to tell an app in the middle of a long-lived event "
"handler that it is OK to temporarily release control back to the event "
"loop, as long as we can resume where we left off. It's up to the app to "
"determine when this release can occur; but if the app releases control to"
" the event loop regularly, we can have a long-running event handler *and*"
" maintain a responsive UI."
msgstr ""

#: ../../tutorial/tutorial-7.rst:69
msgid ""
"We can do this by using *asynchronous programming*. Asynchronous "
"programming is a way to describe a program that allows the interpreter to"
" run multiple functions a the same time, sharing resources between all "
"the concurrently running functions."
msgstr ""

#: ../../tutorial/tutorial-7.rst:74
msgid ""
"Asynchronous functions (known as *co-routines*) need to explicitly "
"declared as being asynchronous. They also need to internally declare when"
" an opportunity exists to change context to another co-routine."
msgstr ""

#: ../../tutorial/tutorial-7.rst:78
msgid ""
"In Python, asynchronous programming is implemented using the ``async`` "
"and ``await`` keywords, and the `asyncio "
"<https://docs.python.org/3/library/asyncio.html>`__ module in the "
"standard library. The ``async`` keyword allows us to declare that a "
"function is an asynchronous co-routine. The ``await`` keyword provides a "
"way to declare when an opportunity exists to change context to another "
"co-routine. The `asyncio "
"<https://docs.python.org/3/library/asyncio.html>`__ module provides some "
"other useful tools and primitives for asynchronous coding."
msgstr ""

#: ../../tutorial/tutorial-7.rst:88
msgid "Making the tutorial Asynchronous"
msgstr ""

#: ../../tutorial/tutorial-7.rst:90
msgid ""
"To make our tutorial asynchronous, modify the ``say_hello()`` event "
"handler so it looks like this::"
msgstr ""

#: ../../tutorial/tutorial-7.rst:109
msgid "There are only 4 changes in this code from the previous version:"
msgstr ""

#: ../../tutorial/tutorial-7.rst:111
msgid ""
"The method is defined as ``async def``, rather than just ``def``. This "
"tells Python that the method is an asynchronous co-routine."
msgstr ""

#: ../../tutorial/tutorial-7.rst:114
msgid ""
"The client that is created is an asynchronous ``AsyncClient()``, rather "
"than a synchronous ``Client()``. This tells ``httpx`` that it should "
"operate in asynchronous mode, rather than synchronous mode."
msgstr ""

#: ../../tutorial/tutorial-7.rst:118
msgid ""
"The context manager used to create the client is marked as `async`. This "
"tells Python that there is an opportunity to release control as the "
"context manager is entered and exited."
msgstr ""

#: ../../tutorial/tutorial-7.rst:122
msgid ""
"The `get` call is made with an `await` keyword. This instructs the app "
"that while we are waiting for the response from the network, the app can "
"release control to the event loop."
msgstr ""

#: ../../tutorial/tutorial-7.rst:126
msgid ""
"Toga allows you to use regular methods or asynchronous co-routines as "
"handlers; Toga manages everything behind the scenes to make sure the "
"handler is invoked or awaited as required."
msgstr ""

#: ../../tutorial/tutorial-7.rst:130
msgid ""
"If you save these changes and re-run the app (either with ``briefcase "
"dev`` in development mode, or by updating and re-running the packaged "
"app), there won't be any obvious changes to the app. However, when you "
"click on the button to trigger the dialog, you may notice a number of "
"subtle improvements:"
msgstr ""

#: ../../tutorial/tutorial-7.rst:135
msgid ""
"The button returns to an \"unclicked\" state, rather than being stuck in "
"a \"clicked\" state."
msgstr ""

#: ../../tutorial/tutorial-7.rst:138
msgid "The \"beachball\"/\"hourglass\" icon won't appear"
msgstr ""

#: ../../tutorial/tutorial-7.rst:140
msgid ""
"If you move/resize the app window while waiting for the dialog to appear,"
" the window will redraw."
msgstr ""

#: ../../tutorial/tutorial-7.rst:143
msgid "If you try to open an app menu, the menu will appear immediately."
msgstr ""

#: ../../tutorial/tutorial-7.rst:146
msgid "Next steps"
msgstr ""

#: ../../tutorial/tutorial-7.rst:148
msgid ""
"We've now got an application that is slick and responsive, even when it's"
" waiting on a slow API. But it still looks like a tutorial app. Is there "
"anything we can do about that? Turn to :doc:`Tutorial 8 <tutorial-8>` to "
"find out..."
msgstr ""

